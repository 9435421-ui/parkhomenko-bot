# Проект: anton_agency_bot
# Консультант по согласованию перепланировок в РФ

## Бизнес-контекст
- Целевая аудитория: владельцы квартир в России
- Услуга: согласование перепланировок (150-180 тыс ₽ для квартир)
- Триггеры: срочная продажа, требования банка, проверка Жилинспекции

## Типовые документы клиентов
- Поэтажный план с экспликацией
- Выписка из ЕГРН (700 ₽, через Госуслуги)
- Техплан (если нет — выезд инженера 15 000₽)

## Частые запросы
- Объединение в студию
- Объединение комнат
- Объединение с лоджией

## Типовые возражения
- "Дорого" → законодательство меняется, сейчас дешевле чем потом
- "Долго" → без согласования проблемы при продаже
- "Можно без разрешения" → штраф не освобождает от обязанности привести в соответствие

## Техническая структура
- База знаний: JSON-файлы в /data/ и markdown в /docs/
- Бот: Python (aiogram 3.x, Telethon для парсинга)
- БД: SQLite (database/terion.db) с aiosqlite
- Главный файл: main.py (запуск через PM2)
- Конфигурация: config.py, переменные окружения в .env
- Сервисы: ScoutParser (поиск лидов), LeadHunter (генерация ответов), AutoPoster (публикация контента)
- AI: YandexGPT (основной/резервный) → Router AI (fallback)

## Ключевые модули
- handlers/ - обработчики команд и сообщений
- services/ - бизнес-логика (scout_parser, lead_hunter, auto_poster)
- database/ - работа с БД (db.py)
- agents/ - AI агенты (content_agent, image_agent)
- config.py - централизованная конфигурация

## Важные особенности кода
- Асинхронность: все операции БД через async/await
- Модерация: лиды проходят через админ-канал перед отправкой
- Анти-спам: фильтрация каналов, рекламы, ботов
- 3-ступенчатый fallback для AI: YandexGPT 1 → YandexGPT 2 → Router AI
- Миграции БД: автоматические при старте (ALTER TABLE)
- Channel ID: поддержка числовых ID и @username

## Стиль кода
- Python 3.11+
- Async/await для всех I/O операций
- Логирование через logging
- Обработка ошибок с try/except и логированием
- Использование pathlib для путей
- HTML escaping для Telegram сообщений

## Инструкции для Agent Review

При каждой проверке кода, связанного с базой данных, ОБЯЗАТЕЛЬНО проверяй:

### 1. Целостность данных (Quiz → Leads)
Проверь, что ВСЕ поля квиза попадают в таблицу `leads`:
- ✅ Город (`city`) - обязательное поле
- ✅ Тип объекта (`object_type`: квартира/дом/коммерция)
- ✅ Бюджет (`budget`) - если собирается в квизе
- ✅ Этаж (`floor`, `total_floors`) - для квартир
- ✅ Материал дома (`house_material`) - для домов
- ✅ Назначение (`purpose`) - для коммерции
- ✅ Контактные данные (`name`, `phone`) - обязательные
- ✅ Дополнительные поля из квиза не теряются при сохранении

**Критично:** Если поле собирается в квизе, но не сохраняется в БД - это баг!

### 2. Уведомления (Дублирование в ADMIN_GROUP_ID)
Проверь логику отправки уведомлений о новых лидах:
- ✅ Уведомление отправляется ОДИН раз при создании лида
- ✅ Нет дублирования сообщений в `ADMIN_GROUP_ID` (из config.py)
- ✅ Используется правильный `THREAD_ID_HOT_LEADS` для горячих лидов
- ✅ Карточка лида содержит все собранные данные
- ✅ Кнопки модерации (Одобрить/Редактировать/Пропустить) работают корректно

**Критично:** Если одно и то же уведомление отправляется дважды - это баг!

### 3. Асинхронность (Блокирующие вызовы)
Проверь, что нет блокирующих синхронных вызовов в async функциях:
- ✅ Все операции с БД используют `await` (async методы)
- ✅ Все Telegram API вызовы используют `await` (aiogram) или `asyncio.to_thread()` (telebot)
- ✅ Файловые операции (open, read, write) обернуты в `asyncio.to_thread()` или используют `aiofiles`
- ✅ HTTP запросы используют `aiohttp` или `httpx` (async), НЕ `requests`
- ✅ Нет `time.sleep()` в async функциях - только `await asyncio.sleep()`

**Критично:** Если синхронный вызов блокирует event loop - это баг! (как было в AutoPoster)

### Примеры проблемных паттернов:
```python
# ❌ ПЛОХО: синхронный вызов в async функции
async def save_lead():
    db.save_lead(...)  # блокирует event loop!

# ✅ ХОРОШО: async вызов
async def save_lead():
    await db.save_lead(...)

# ❌ ПЛОХО: синхронный bot в async функции
async def send_notification():
    bot.send_message(...)  # блокирует event loop!

# ✅ ХОРОШО: async bot или asyncio.to_thread
async def send_notification():
    await bot.send_message(...)  # aiogram
    # или
    await asyncio.to_thread(bot.send_message, ...)  # telebot
```
